/************************************
 *
 * File : EPucSim_remoteControl.cic
 * Date : Oct 28, 2022 10:46 AM
 *
*************************************/

/////////////////////////////////////
// include header section
/////////////////////////////////////
TASK_CODE_BEGIN
#include <random>
#include <cmath>
using namespace std;
/////////////////////////////////////
// global definition
/////////////////////////////////////

// ##DEFINE_PORT_SECTION::START
static int ret_port;
static int room_port;
static int fire_group;
static int fire_port;
static int extinguish_group;
static int extinguish_port;
static int led_group;
static int led_port;
// ##DEFINE_PORT_SECTION::END

typedef struct _EPUCK_LED {
    int power;
    double red;
    double green;
    double blue;
} EPUCK_LED;

static EPUCKSIM_MOVE_PORTS ports;
static int turning_mechanism;
static int room;

static double target[2] = {0.0, 0.0};

static double offset[3][2][2] = {
    {{-2.35, -1.375}, {0.275, 2.3}},
    {{-1.175, 0.825}, {0.275, 2.3}},
    {{1.075, 2.1}, {0.275, 2.3}}
};

static int bound[3][2] = {
    {20, 50},
    {50, 50},
    {20, 50}
};

static semo_int8 map[50][50] = {0,};
static int init = FALSE;
/////////////////////////////////////
// init code
/////////////////////////////////////

TASK_INIT
{
// ##INIT_PORT_SECTION::START
    UFPort_Initialize(TASK_ID, "result", &ret_port);
    UFPort_Initialize(TASK_ID, "room", &room_port);
    UFMulticastPort_Initialize(TASK_ID, "detectFire", &fire_group, &fire_port);
    UFMulticastPort_Initialize(TASK_ID, "extinguish", &extinguish_group, &extinguish_port);
    UFMulticastPort_Initialize(TASK_ID, "led", &led_group, &led_port);
    UFMulticastPort_Initialize(TASK_ID, "position", &ports.position_group, &ports.position_port);
    UFMulticastPort_Initialize(TASK_ID, "orientation", &ports.orientation_group, &ports.orientation_port);
    UFMulticastPort_Initialize(TASK_ID, "proximity", &ports.proximity_group, &ports.proximity_port);
    UFMulticastPort_Initialize(TASK_ID, "wheel", &ports.wheel_group, &ports.wheel_port);
    move_init(&turning_mechanism);

// ##INIT_PORT_SECTION::END
    
    // TODO: task initialize code
    
    int dataNum;
    EPUCK_LED led = {1, -1, 1, -1};
    UFMulticastPort_WriteToBuffer(led_group, led_port, (unsigned char *)&led, sizeof(EPUCK_LED), &dataNum); 
    target[0] = 0.0;
    target[1] = 0.0;
    for (int w = 0 ; w < 50 ; w++) {
        for (int h = 0 ; h < 50 ; h++) {
            map[w][h] = 0;
        }
    }
    room = 0;
    init = FALSE;
}


/////////////////////////////////////
// go code
/////////////////////////////////////
static int map_complete() {
    for (int w = 0 ; w < bound[room][0] ; w++) {
        for (int h = 0 ; h < bound[room][1] ; h++) {
            if (map[w][h] == 0) {
                return FALSE;
            }
        }
    }
    return TRUE;
}

static void get_next_target(double *target) {
    int position[2];
    while (map_complete()==FALSE){
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_real_distribution<> x_dis(0, bound[room][0]);
        position[0] = x_dis(gen);
        std::uniform_real_distribution<> y_dis(0, bound[room][1]);
        position[1] = y_dis(gen);
        if (map[position[0]][position[1]] == 0) {
            target[0] = (position[0]*(offset[room][0][1]-offset[room][0][0]))/bound[room][0] + offset[room][0][0];
            target[1] = (position[1]*(offset[room][1][1]-offset[room][1][0]))/bound[room][1] + offset[room][1][0];
            return;
        }
    }
}

static void update_map() {
    int dataLength;
    double position[3];
    int robotNum;
    int robotList[SEMO_ROBOT_NUM];
    semo_int8 otherMap[SEMO_ROBOT_NUM][50][50] = {0,};
    UFMulticastPort_ReadFromBuffer(ports.position_group, ports.position_port, (unsigned char *)position, sizeof(double) * 3, &dataLength);
    position[0] = (position[0] - offset[room][0][0]) * bound[room][0] / (offset[room][0][1] - offset[room][0][0]);
    position[1] = bound[room][1] - (position[1] - offset[room][1][0]) * bound[room][1] / (offset[room][1][1] - offset[room][1][0]);
    for (int w = -3 ; w <= 3 ; w++){
        for (int h = -3 ; h <= 3 ; h++){
            if (sqrt(pow(w, 2) + pow(h, 2)) <= 3 &&
                position[0] + w < bound[room][0] && position[0] + w >= 0 &&
                position[1] + h < bound[room][1] && position[1] + h >= 0) {
                map[(int)position[0] + w][(int)position[1] + h] = 1;
            }
        }
    }

    LIBCALL(map, get_shared_data_action, &robotNum, robotList, (semo_int8*) otherMap);
    for (int i = 0 ; i < robotNum ; i ++){
        for (int w = 0 ; w < bound[room][0] ; w++) {
            for (int h = 0 ; h < bound[room][1] ; h++) {
                if (otherMap[i][w][h] == 1) {
                    map[w][h] = 1;
                }
            }
        }
    }

    LIBCALL(map, set_shared_data_action, (semo_int8*) map);
}

TASK_GO
{
    int result = FALSE;
    int result_list[SEMO_ROBOT_NUM];
    int robot_num;
    int robot_list[SEMO_ROBOT_NUM];
    int dataLength;
    double fire[4];

    result = UFPort_ReadFromBuffer(room_port, (unsigned char *)&room, sizeof(int), 0, &dataLength);
    ERRIFGOTO(result, EXIT_);

    LIBCALL(result, get_shared_data_action, &robot_num, robot_list, result_list);
    for (int i = 0 ; i < robot_num ; i++) {
        result |= result_list[i];
    }
    if (result == TRUE) {
        int ret = TRUE;
        result = UFPort_WriteToBuffer(ret_port, (unsigned char *)&ret, sizeof(int), 0, &dataLength);
        ERRIFGOTO(result, EXIT_);
        return;
    }

    result = UFMulticastPort_ReadFromBuffer(fire_group, fire_port, (unsigned char *)fire, sizeof(double) * 4, &dataLength);
    ERRIFGOTO(result, EXIT_);

    if (fire[0] > 0) {
        int ret = TRUE;
        SEMO_LOG_INFO("robot %s start extinguish", THIS_ROBOT_NAME);
        result = UFMulticastPort_WriteToBuffer(extinguish_group, extinguish_port, (unsigned char *)&room, sizeof(int), &dataLength);
        ERRIFGOTO(result, EXIT_);
        LIBCALL(result, set_shared_data_action, &ret);
        result = UFPort_WriteToBuffer(ret_port, (unsigned char *)&ret, sizeof(int), 0, &dataLength);
        ERRIFGOTO(result, EXIT_);
        return;
    }

    if (map_complete() == TRUE) {
        int ret = 0;
        result = UFPort_WriteToBuffer(ret_port, (unsigned char *)&ret, sizeof(int), 0, &dataLength);
        ERRIFGOTO(result, EXIT_);
        return;
    }

    update_map();
    if (is_arrived(&ports, target) == TRUE || init == FALSE) {
        get_next_target(target);
        init = TRUE;
    }
    move_to_target(&ports, &turning_mechanism, target);

EXIT_:
    if (result != ERR_UEM_NOERROR) {
        SEMO_LOG_ERROR("Communication error(%X)", result);
    }
}


/////////////////////////////////////
// wrapup code
/////////////////////////////////////

TASK_WRAPUP
{
    // TODO: task wrapup code
    int dataNum;
    EPUCK_LED led = {1, -1, 0, -1};
    UFMulticastPort_WriteToBuffer(led_group, led_port, (unsigned char *)&led, sizeof(EPUCK_LED), &dataNum); 
    move_wrapup(&ports);
}

TASK_CODE_END