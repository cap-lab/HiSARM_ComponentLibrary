/************************************
 *
 * File : EPucSim_remoteControl.cic
 * Date : Oct 28, 2022 10:46 AM
 *
*************************************/

/////////////////////////////////////
// include header section
/////////////////////////////////////
#include <iostream>
#include <cmath>

TASK_CODE_BEGIN

/////////////////////////////////////
// global definition
/////////////////////////////////////

// ##DEFINE_PORT_SECTION::START
static int group_port;
static int position_group;
static int position_port;
static int orientation_group;
static int orientation_port;
static int wheel_group;
static int wheel_port;
static int ultrasonic_group;
static int ultrasonic_port;
// ##DEFINE_PORT_SECTION::END

#define PI 3.14159265358979
#define MAX_VEL 5.0
#define SCALE_VEL 5.0

static double points[3][2] = {
    {0.9, -0.85},
    {0.9, -2.1},
    {-2.1, -2.1}
};

enum turning {
    NO_TURN,
    SOFT_TURN,
    HARD_TURN
};

typedef struct _P3DX_WHEEL {
    double left_vel;
    double right_vel;
} P3DX_WHEEL;

using namespace std;

static int myRole;
static int robotNum;
static int robotId[10];
static int count = 0;
static int turningMechanism = NO_TURN;
/////////////////////////////////////
// init code
/////////////////////////////////////

TASK_INIT
{
// ##INIT_PORT_SECTION::START
    UFMulticastPort_Initialize(TASK_ID, "wheel", &wheel_group, &wheel_port);
    UFMulticastPort_Initialize(TASK_ID, "position", &position_group, &position_port);
    UFMulticastPort_Initialize(TASK_ID, "orientation", &orientation_group, &orientation_port);
    UFMulticastPort_Initialize(TASK_ID, "ultrasonic", &ultrasonic_group, &ultrasonic_port);

// ##INIT_PORT_SECTION::END
    
    // TODO: task initialize code
    count = 0;
    myRole = -1;
    robotNum = 0;
    turningMechanism = NO_TURN;
}


/////////////////////////////////////
// go code
/////////////////////////////////////

static double eulerOrientationToRadian(double *orientation)
{
    double radian;
    radian = orientation[2];
    return radian;
}

static double signedNormalize(double radian){
    while(radian > PI) {
        radian -= 2*PI;
    }
    while(radian < -PI) {
        radian += 2*PI;
    }
    return radian;
}

static double vectorToRadian(double *vector)
{
    return atan2(vector[1], vector[0]);
}

static void vectorSum(double *vector1, double *vector2, double *vector)
{
    vector[0] = vector1[0] + vector2[0];
    vector[1] = vector1[1] + vector2[1];
}

static double lengthOfVector(double *vector)
{
    return sqrt(vector[0] * vector[0] + vector[1] * vector[1]);
}

static void getVectorFromRadianAndLength(double radian, double length, double *vector)
{
    vector[0] = cos(radian) * length;
    vector[1] = sin(radian) * length;
}

static int aroundPoint(double *point, double *position)
{
    if (position[0] >= point[0] - 0.5 && position[0] <= point[0] + 0.5 &&
        position[1] >= point[1] - 0.5 && position[1] <= point[1] + 0.5) {
        return TRUE;
    } else {
        return FALSE;
    }
}

static uem_result vectorToTarget(double *targetPoint, double *position, double *vector)
{
    double targetRadian;
    uem_result result;
    double currentOrientation[3];
    int dataLength;
    result = UFMulticastPort_ReadFromBuffer(orientation_group, orientation_port, (unsigned char *)currentOrientation, sizeof(double) * 3, &dataLength);
    vector[0] = targetPoint[0] - position[0];
    vector[1] = targetPoint[1] - position[1];
    targetRadian = vectorToRadian(vector);
    if (currentOrientation[2] > 2*PI || currentOrientation[2] < -2*PI){
        getVectorFromRadianAndLength(signedNormalize(targetRadian), lengthOfVector(vector), vector);
    } else {
        getVectorFromRadianAndLength(signedNormalize(targetRadian-eulerOrientationToRadian(currentOrientation)), lengthOfVector(vector), vector);
    }
    return result;
}

static void diffusionVector(int *collision, double *vector)
{
    double ultrasonicValue[16];
    double tempVector[2] = {0, 0};
    double ultrasonicRadians[8] = {PI/2, PI*5/14, PI*3/14, PI*1/14, -PI*1/14, -PI*3/14, -PI*5/14, -PI/2};
    double ultrasonicCounterRadians[8] = {-PI/2, -PI*9/14, -PI*11/14, -PI*13/14, PI*13/14, PI*11/14, PI*9/14, PI/2, };
    int dataLength;
	int count = 0;
    *collision = FALSE;
    UFMulticastPort_ReadFromBuffer(ultrasonic_group, ultrasonic_port, (unsigned char *)ultrasonicValue, sizeof(double) * 16, &dataLength);
    for (int i=1 ; i < 7 ; i++){
        double temp[2] = {0, 0};
        if(ultrasonicValue[i] >  0.0) {
			count++;
            getVectorFromRadianAndLength(ultrasonicRadians[i], ultrasonicValue[i], temp);
        } else {
            getVectorFromRadianAndLength(ultrasonicRadians[i], 0.7, temp);
        }
        vectorSum(tempVector, temp, tempVector);
    }
	if (count>=2) *collision = TRUE;
    for (int i = 0 ; i < 8 ; i++) {
        double temp[2] = {0, 0};
        getVectorFromRadianAndLength(ultrasonicCounterRadians[i], 0.7, temp);
        vectorSum(tempVector, temp, tempVector);
    }
    if(*collision == TRUE) {
        vector[0] = -(tempVector[1]);
        vector[1] = -(tempVector[0]);
    } else {
        *collision = FALSE;
        vector[0] = 0;
        vector[1] = 0;
    }
}

static uem_result setWheelSpeedFromVector(double *vector, int collision)
{
    int dataNum;
    double radian;
    double length;
    double baseAngularWheelSpeed;
    radian = signedNormalize(vectorToRadian(vector));
    length = lengthOfVector(vector);
    baseAngularWheelSpeed = min(length, MAX_VEL);
    if(turningMechanism == HARD_TURN) {                                         
       if(abs(radian) <= PI/3) {
          turningMechanism = SOFT_TURN;
       }
    }
    if(turningMechanism == SOFT_TURN) {
       if(abs(radian) > PI/2) {
          turningMechanism = HARD_TURN;
       }
       else if(abs(radian) <= PI/6) {
          turningMechanism = NO_TURN;
          baseAngularWheelSpeed = MAX_VEL;
       }
    }
    if(turningMechanism == NO_TURN) {
       if(abs(radian) > PI/2) {
          turningMechanism = HARD_TURN;
       }
       else if(abs(radian) > PI/6) {
          turningMechanism = SOFT_TURN;
       } else {
          baseAngularWheelSpeed = MAX_VEL;
       }
    }
    P3DX_WHEEL vel;
    switch(turningMechanism){
        case NO_TURN:
            vel.left_vel = baseAngularWheelSpeed;
            vel.right_vel = baseAngularWheelSpeed;
            break;
        case SOFT_TURN:
                vel.left_vel = baseAngularWheelSpeed - baseAngularWheelSpeed*(1 - radian / PI);
                vel.right_vel = baseAngularWheelSpeed + baseAngularWheelSpeed * (1 - radian / PI);
            break;
        case HARD_TURN:
                vel.left_vel = -baseAngularWheelSpeed;
                vel.right_vel = +baseAngularWheelSpeed;
            break;
    }
    if (radian < 0) {
        double temp;
        temp = vel.right_vel;
        vel.right_vel = vel.left_vel;
        vel.left_vel = temp;
    }
    if (collision == TRUE){
		if (turningMechanism == SOFT_TURN){
			vel.left_vel = -vel.left_vel/SCALE_VEL;
			vel.right_vel = -vel.right_vel/SCALE_VEL;
		} else if (turningMechanism == NO_TURN){
			vel.left_vel = -1;
		    vel.right_vel = -1;
		}
	}
    //SEMO_LOG_INFO("robot %s, turn mode %d, radian %f, vel (%f,%f)", THIS_ROBOT_NAME, turningMechanism, radian, vel.left_vel, vel.right_vel);
    return UFMulticastPort_WriteToBuffer(wheel_group, wheel_port, (unsigned char *)&vel, sizeof(P3DX_WHEEL), &dataNum);
}

TASK_GO
{
    int result;
    int dataLength;

    myRole = 0;
    int myId = THIS_ROBOT_ID;
    LIBCALL(robot_id, get_shared_data_action, &robotNum, robotId, robotId);
    for (int i = 0 ; i < robotNum ; i++) {
        if (robotId[i] < THIS_ROBOT_ID) {
            myRole++;
        }
    }
    LIBCALL(robot_id, set_shared_data_action, &myId);

    if(myRole >= 0) {
        int collision;
        double position[3];
        double vector[2];
        double diffusedVector[2];
        double targetPoint[2];
        result = UFMulticastPort_ReadFromBuffer(position_group, position_port, (unsigned char *)position, sizeof(double) * 3, &dataLength);
        ERRIFGOTO(result, EXIT_);
        targetPoint[0] = points[count][0];
        targetPoint[1] = points[count][1];
        result = vectorToTarget(targetPoint, position, vector);
        ERRIFGOTO(result, EXIT_);
        diffusionVector(&collision, diffusedVector);
		if (collision == FALSE) {
			vector[0] *= SCALE_VEL;
			vector[1] *= SCALE_VEL;
        } else {
			diffusedVector[0] *= SCALE_VEL;
			diffusedVector[1] *= SCALE_VEL;
		}
        vectorSum(vector, diffusedVector, vector);
        if (aroundPoint(targetPoint, position) == TRUE) {
            if (myRole > count) {
                count++;
            }
            if (myRole <= count) {
                vector[0] = 0;
                vector[1] = 0;
				collision = FALSE;
            }
        }
        result = setWheelSpeedFromVector(vector, collision);
    }
EXIT_:
    if (result != ERR_UEM_NOERROR) {
        SEMO_LOG_ERROR("Communication error(%X)", result);
    }
}


/////////////////////////////////////
// wrapup code
/////////////////////////////////////

TASK_WRAPUP
{
    // TODO: task wrapup code
    P3DX_WHEEL vel = {0, 0};
    int dataNum;
    UFMulticastPort_WriteToBuffer(wheel_group, wheel_port, (unsigned char *)&vel, sizeof(P3DX_WHEEL), &dataNum);
}

TASK_CODE_END
