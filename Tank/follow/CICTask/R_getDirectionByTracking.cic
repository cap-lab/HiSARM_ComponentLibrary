/************************************
 *
 * File : checkDistanceByTracking.cic
 * Date : Oct 28, 2022 10:46 AM
 *
*************************************/

/////////////////////////////////////
// include header section
/////////////////////////////////////
#include <iostream>
#include <string>
#include <thread>
#include <chrono>
#include <opencv2/opencv.hpp>
#include "opencv2/imgcodecs.hpp"
#include "opencv2/highgui.hpp"
#include "opencv2/imgproc.hpp"

// ##DEFINE_SECTION::START
// ##DEFINE_SECTION::END


TASK_CODE_BEGIN

/////////////////////////////////////
// global definition
/////////////////////////////////////

// ##DEFINE_PORT_SECTION::START
STATIC int port_direction;
// ##DEFINE_PORT_SECTION::END

enum DIRECTION {
    FORWARD_,
    LEFT_,
    BACKWARD_,
    RIGHT_,
    STOP_
};

static int direction;

static cv::VideoCapture cap;
static cv::Mat frame;
cv::Mat detectObjectByColor(const cv::Mat &frame);

/////////////////////////////////////
// init code
/////////////////////////////////////

TASK_INIT
{
// ##INIT_PORT_SECTION::START
    port_direction = PORT_INITIALIZE(TASK_ID, "direction");
// ##INIT_PORT_SECTION::END

    std::string cmd = "v4l2rtspserver -W 480 -H 480 -F 15 -P 8554 /dev/video0 &";
    //run process with shell
    system(cmd.c_str());

    std::this_thread::sleep_for(std::chrono::seconds(2));
    
    // TODO: task initialize code
    cap.open("rtsp://127.0.0.1:8554/unicast");
    if(!cap.isOpened()) {
        std::cout<<"Failed to open camera."<<std::endl;
    }
     
    cv::namedWindow("Tracking", cv::WINDOW_AUTOSIZE);

    direction=STOP_;
}


/////////////////////////////////////
// go code
/////////////////////////////////////

TASK_GO
{
    // TODO: task main code
    if (cap.read(frame)) {
        //image_processing
        cv::Mat processed_image = detectObjectByColor(frame);
        //Calculate the moments of the threshold image
        cv::Moments theMoments = cv::moments(processed_image);
        
        double dM01 = theMoments.m01;
        double dM10 = theMoments.m10;
        double dArea = theMoments.m00;

        // if the area <= 10000, lets consider that there are no objects in the image because of the noise
        if(dArea> 10000)
        {
            //calculate the position of the ball
            int center_x = dM10/dArea;
            int center_y  =dM01/dArea;
            
            //for debugging
            if (center_x >=0 && center_y >=0){
                cv::circle(frame, cv::Point(center_x, center_y), 10, cv::Scalar(255,255,255),2);
                std::cout << "center_x=" << center_x << "  center_y=" << center_y << std::endl;
            }

            int width = frame.size().width;
            if(center_x <= (width/3)){
                direction = LEFT_;
            }else if (center_x > (width*2/3)){
                direction = RIGHT_;
            }else{
                direction = FORWARD_;
            }
            
            cv::imshow("Tracking", frame);
            cv::waitKey(5);
        }        
    }else{
        std::cout<<"Capture read error"<<std::endl;
    }
        
    int numOfWrite;
    UFPort_WriteToBuffer(port_direction, (unsigned char *)&direction, sizeof(int), 0, &numOfWrite);
}


cv::Mat detectObjectByColor(const cv::Mat &frame){
    cv::Mat imageHSV;      
     //convert the capture fram from BGR TO HSV
     cv::cvtColor(frame, imageHSV, cv::COLOR_BGR2HSV);     
 
     //threshold the image
     cv::Mat imageThresholded;
     //cv::inRange(imageHSV, cv::Scalar(lowValueHue,lowValueSat,lowValueVal), cv::Scalar(highValueHue,hig    hValueSat,highValueVal), imageThresholded);
     cv::inRange(imageHSV, cv::Scalar(0, 0, 0), cv::Scalar(100, 255, 33.16), imageThresholded);
     
     //morphologoical opening(remove small objects from the foreground)
     cv::erode(imageThresholded, imageThresholded, cv::getStructuringElement(cv::MORPH_ELLIPSE, cv::Size(    5,5)));
     cv::dilate(imageThresholded, imageThresholded, cv::getStructuringElement(cv::MORPH_ELLIPSE, cv::Size    (5,5)));
     
     //morphological closing fill in small holes of the foreground)
     cv::dilate(imageThresholded, imageThresholded, cv::getStructuringElement(cv::MORPH_ELLIPSE, cv::Size    (5,5)));
     cv::erode(imageThresholded, imageThresholded, cv::getStructuringElement(cv::MORPH_ELLIPSE, cv::Size(    5,5)));
     
     return imageThresholded;
 }
 

/////////////////////////////////////
// wrapup code
/////////////////////////////////////

TASK_WRAPUP
{
    // TODO: task wrapup code
    cap.release();
    cv::destroyAllWindows();
    
	std::string cmd = "pkill v4l2rtspserver";
    system(cmd.c_str());
}


TASK_CODE_END
