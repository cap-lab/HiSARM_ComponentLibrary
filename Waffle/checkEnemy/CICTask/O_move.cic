/************************************
 *
 * File : O_move.cic
 * Date : Nov 18, 2022 4:51 PM
 *
*************************************/

/////////////////////////////////////
// include header section
/////////////////////////////////////
#include <inttypes.h>
#include <DynamixelSDK.h>
#include <Arduino.h>


// ##DEFINE_SECTION::START
#define WHEEL_NUM                        2
#define LINEAR                           0
#define ANGULAR                          1
#define CONTROL_PERIOD                   8000

#define MAX_LINEAR_VELOCITY 0.22
#define MAX_ANGULAR_VELOCITY 2.84
#define INITIAL_LINEAR_X (MAX_LINEAR_VELOCITY/3)
#define INITIAL_ANGULAR_Z (MAX_ANGULAR_VELOCITY)
// ##DEFINE_SECTION::END


TASK_CODE_BEGIN

/////////////////////////////////////
// global definition
/////////////////////////////////////

// ##DEFINE_PORT_SECTION::START
// ##DEFINE_PORT_SECTION::END

// ##DEFINE_MULTICAST_PORT_SECTION::START
// ##DEFINE_MULTICAST_PORT_SECTION::END

static HardwareTimer Timer(TIMER_CH1);
static Turtlebot3MotorDriver motor_driver;
static float goal_velocity[WHEEL_NUM] = {0.0, 0.0};

enum DIRECTION {
    FORWARD_,
    LEFT_,
    BACKWARD_,
    RIGHT_,
    STOP_
};

typedef struct _ControlVelocity{
    double linear_x;
    double angular_z;
} ControlVelocity;

static void controlMoter();
static void startDynamixelControlInterrupt();
static void turn(int direction);
static void convertDirectionToMotorVelocity(const int &direction, ControlVelocity &vel);

/////////////////////////////////////
// init code
/////////////////////////////////////

TASK_INIT
{
// ##INIT_PORT_SECTION::START
// ##INIT_PORT_SECTION::END

// ##INIT_MULTICAST_PORT_SECTION::START
// ##INIT_MULTICAST_PORT_SECTION::END

    // TODO: task initialize code
    motor_driver.init(NAME);
    startDynamixelControlInterrupt();
    
    //turn 180 degree
    turn(RIGHT_);
    turn(RIGHT_);
}

static void controlMoter(){
    motor_driver.controlMotor(WHEEL_RADIUS, WHEEL_SEPARATION, goal_velocity);
}

static void startDynamixelControlInterrupt(){
    Timer.pause();
    Timer.setPeriod(CONTROL_PERIOD);           // in microseconds
    Timer.attachInterrupt(controlMoter);
    Timer.refresh();
    Timer.resume();
}



/////////////////////////////////////
// go code
/////////////////////////////////////

TASK_GO
{
    // TODO: task main code
    //turn(LEFT_);
    //delay(3000); 
    //turn(RIGHT_);
    //delay(3000); 
}

static void turn(int direction){
    ControlVelocity vel = {0, 0};
    convertDirectionToMotorVelocity(direction, vel);

    goal_velocity[LINEAR]  = vel.linear_x;
    goal_velocity[ANGULAR]  = vel.angular_z;

    delay(3850); 
    goal_velocity[LINEAR]  = 0.0;
    goal_velocity[ANGULAR]  = 0.0;
}

static void convertDirectionToMotorVelocity(const int &direction, ControlVelocity &vel){
    switch(direction)
    {        
        case STOP_:           
            vel.linear_x = 0;
            vel.angular_z = 0;
            break;
        case FORWARD_:
            vel.linear_x = INITIAL_LINEAR_X;
            vel.angular_z = 0;
            break;
        case BACKWARD_:
            vel.linear_x = -1 * INITIAL_LINEAR_X;
            vel.angular_z = 0;
            break;
        case RIGHT_:
            vel.linear_x = 0;
            vel.angular_z = INITIAL_ANGULAR_Z/7*1.88;
            break;
        case LEFT_:
            vel.linear_x = 0;
            vel.angular_z = -1 * INITIAL_ANGULAR_Z/7*1.88;
            break;   
        default:
            break;
    }
}



/////////////////////////////////////
// wrapup code
/////////////////////////////////////

TASK_WRAPUP
{
    // TODO: task wrapup code

}

TASK_CODE_END
