/************************************
 *
 * File : R_controlAndReport.cic
 * Date : Nov 17, 2022 10:38 AM
 *
*************************************/

/////////////////////////////////////
// include header section
/////////////////////////////////////
#include <iostream>
#include <string>

// ##DEFINE_SECTION::START
#define YELLOW 4
#define RED 3
#define BLACK 2
// ##DEFINE_SECTION::END

enum DIRECTION {
    FORWARD_,
    LEFT_,
    BACKWARD_,
    RIGHT_,
    STOP_
};

TASK_CODE_BEGIN

/////////////////////////////////////
// global definition
/////////////////////////////////////

// ##DEFINE_PORT_SECTION::START
STATIC int port_color;
STATIC int port_distance;
STATIC int port_target;
STATIC int port_group;
STATIC int port_direction;
STATIC int port_isFound;
STATIC int port_isLeader;
// ##DEFINE_PORT_SECTION::END

// ##DEFINE_MULTICAST_PORT_SECTION::START
// ##DEFINE_MULTICAST_PORT_SECTION::END

static int distance = 8000;
static int isFound = 0;

/////////////////////////////////////
// init code
/////////////////////////////////////

TASK_INIT
{
// ##INIT_PORT_SECTION::START
    port_color = PORT_INITIALIZE(TASK_ID, "color");
    port_distance = PORT_INITIALIZE(TASK_ID, "distance");
    port_target = PORT_INITIALIZE(TASK_ID, "target");
    port_group = PORT_INITIALIZE(TASK_ID, "group");
    port_direction = PORT_INITIALIZE(TASK_ID, "direction");
    port_isFound = PORT_INITIALIZE(TASK_ID, "isFound");
    port_isLeader = PORT_INITIALIZE(TASK_ID, "isLeader");
// ##INIT_PORT_SECTION::END

// ##INIT_MULTICAST_PORT_SECTION::START
// ##INIT_MULTICAST_PORT_SECTION::END

    // TODO: task initialize code
}

static int count=0;

/////////////////////////////////////
// go code
/////////////////////////////////////

TASK_GO
{
    // TODO: task main code
    int dataLength;
    int color = 0;
    int direction = STOP_;
    int target = 0;
    int group = 0;
    int isLeader = 0;
    UFPort_ReadFromBuffer(port_group, (unsigned char *)&group, sizeof(int), 0 , &dataLength);
    UFPort_ReadFromBuffer(port_target, (unsigned char *)&target, sizeof(int), 0 , &dataLength);
    UFPort_ReadFromBuffer(port_color, (unsigned char *)&color, sizeof(int), 0 , &dataLength);
    UFPort_ReadFromQueue(port_distance, (unsigned char *)&distance, sizeof(int), 0 , &dataLength);
    if (isFound == 0){
        std::string robotName = THIS_ROBOT_NAME;
        if(robotName.compare("Burger_1")){ // Because Burger shows a different color sensor value, target value is modified to detect the same color of other robots
            target += 2;
        }

        if (color == target){
            count++;
        }else {
            count=0;
        }

        if (count > 2){ // to avoid error of fault sensor value, three continuous values must be detected to stop the search operation.
            isFound=1;
            std::cout << "target found" << std::endl;
            direction = STOP_;
        }else{  // if the distance is too close to obstacles or too far from the obstacles, the robot turns left to change the direction 
            if(distance < 350 || distance > 2000){ 
                direction = LEFT_;
            }else{
                direction = FORWARD_;
            }
        }
    }
    
	printf("color: %d, count: %d, target: %d, direction: %d, distance: %d\n", color, count, target, direction, distance);

    UFPort_WriteToBuffer(port_direction, (unsigned char *)&direction, sizeof(int), 0 , &dataLength);
    UFPort_WriteToBuffer(port_isFound, (unsigned char *)&isFound, sizeof(int), 0 , &dataLength);
    if (LIBCALL(leader, get_leader_selection_state, group) == LEADER_SELECTION_SELECTED) {
        isLeader = LIBCALL(leader, get_leader, group);
        if (isLeader == THIS_ROBOT_ID){
            isLeader = 1;
            SEMO_LOG_INFO("I'm leader (%d) of group: %d", THIS_ROBOT_ID, group);
            UFPort_WriteToBuffer(port_isLeader, (unsigned char *)&isLeader, sizeof(int), 0 , &dataLength);
        } else {
            isLeader = 0;
            SEMO_LOG_INFO("I'm not leader (%d) of group: %d", THIS_ROBOT_ID, group);
            UFPort_WriteToBuffer(port_isLeader, (unsigned char *)&isLeader, sizeof(int), 0 , &dataLength);
        }
    }
}

/////////////////////////////////////
// wrapup code
/////////////////////////////////////

TASK_WRAPUP
{
    // TODO: task wrapup code

}

TASK_CODE_END
