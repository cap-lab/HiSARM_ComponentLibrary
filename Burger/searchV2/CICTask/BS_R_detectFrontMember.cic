/************************************
 *
 * File : R_detectFrontMember.cic
 * Date : Mar 14, 2023, 1:38 PM
 *
 *************************************/

/////////////////////////////////////
// include header section
/////////////////////////////////////

//#include <time.h>
//#include <sys/time.h>

#include <opencv2/opencv.hpp>
#include "opencv2/imgcodecs.hpp"
#include "opencv2/highgui.hpp"
#include "opencv2/imgproc.hpp"

// ##DEFINE_SECTION::START
// ##DEFINE_SECTION::END

TASK_CODE_BEGIN

/////////////////////////////////////
// global definition
/////////////////////////////////////

// ##DEFINE_PORT_SECTION::START
STATIC int port_isFrontMember;
// ##DEFINE_PORT_SECTION::END

/*static long long s_llCurTime = 0;
static long long s_llStartTime = 0;

static long long getCurTickInMicroSeconds()
{
    long long tTime = 0;
    struct timespec stTime;
    int nRet = 0;

    nRet = clock_gettime(CLOCK_MONOTONIC, &stTime);

    tTime = (((long long) stTime.tv_sec) * 1000000) + (stTime.tv_nsec / 1000);

    return tTime;
}*/


static cv::VideoCapture cap;
static cv::Mat frame;
cv::Mat detectObjectByColor(const cv::Mat &frame);

static int isFrontMember;
/////////////////////////////////////
// init code
/////////////////////////////////////

static int number = 0;

TASK_INIT
{
    // ##INIT_PORT_SECTION::START
    port_isFrontMember = PORT_INITIALIZE(TASK_ID, "isFrontMember");
    // ##INIT_PORT_SECTION::END

    // TODO: task initialize code
    cap.open("rtsp://127.0.0.1:8554/unicast");
    if (!cap.isOpened())
    {
        std::cout << "Failed to open camera." << std::endl;
    }

    isFrontMember = 1;

    number = 0;
}

/////////////////////////////////////
// go code
/////////////////////////////////////

TASK_GO
{
    // TODO: task main code
     //s_llStartTime = getCurTickInMicroSeconds();

    if (cap.read(frame))
    {
        number++;
        // image_processing
        cv::Mat processed_image = detectObjectByColor(frame);

        // Calculate the moments of the threshold image
        cv::Moments theMoments = cv::moments(processed_image);

        // double dM01 = theMoments.m01;
        double dM10 = theMoments.m10;
        double dArea = theMoments.m00;

        std::cout << "dArea : " << dArea << std::endl;
        // if the area <= 10000, lets consider that there are no objects in the image because of the noise
        if (dArea > 5000000)
        {
            // calculate the position of the ball
            int center_x = dM10 / dArea;

            int width = frame.size().width;
            if (center_x > (width / 3) || center_x < (width * 2 / 3))
            {
                isFrontMember = 1;
                std::cout << "Front member detected" << std::endl;
            } else {
                isFrontMember = 0;
                std::cout << "No Front member" << std::endl;
            }
        }else {
            isFrontMember = 0;
            std::cout << "No Front member_" << std::endl;
        }

        cv::waitKey(5);
    }
    else
    {
        std::cout << "Capture read error. " << number << std::endl;
        cap.release();
        number = 0;
        cap.open("rtsp://127.0.0.1:8554/unicast");
        if (!cap.isOpened())
        {
            std::cout << "Failed to reopen camera." << std::endl;
        }
    }

    int numOfWrite;
    UFPort_WriteToBuffer(port_isFrontMember, (unsigned char *)&isFrontMember, sizeof(int), 0, &numOfWrite);

    //s_llCurTime = getCurTickInMicroSeconds();
    //std::cout << "elapsed time: " << (s_llCurTime - s_llStartTime) << std::endl;

}

cv::Mat detectObjectByColor(const cv::Mat &frame)
{
    cv::Mat imageHSV;
    // convert the capture fram from BGR TO HSV
    cv::cvtColor(frame, imageHSV, cv::COLOR_BGR2HSV);

    // threshold the image
    cv::Mat imageThresholded;
    // cv::inRange(imageHSV, cv::Scalar(lowValueHue,lowValueSat,lowValueVal), cv::Scalar(highValueHue,hig    hValueSat,highValueVal), imageThresholded);
    cv::inRange(imageHSV, cv::Scalar(0, 0, 0), cv::Scalar(200, 255, 65), imageThresholded);

    // morphologoical opening(remove small objects from the foreground)
    cv::erode(imageThresholded, imageThresholded, cv::getStructuringElement(cv::MORPH_ELLIPSE, cv::Size(5, 5)));
    cv::dilate(imageThresholded, imageThresholded, cv::getStructuringElement(cv::MORPH_ELLIPSE, cv::Size(5, 5)));

    // morphological closing fill in small holes of the foreground)
    cv::dilate(imageThresholded, imageThresholded, cv::getStructuringElement(cv::MORPH_ELLIPSE, cv::Size(5, 5)));
    cv::erode(imageThresholded, imageThresholded, cv::getStructuringElement(cv::MORPH_ELLIPSE, cv::Size(5, 5)));

    return imageThresholded;
}

/////////////////////////////////////
// wrapup code
/////////////////////////////////////

TASK_WRAPUP
{
    // TODO: task wrapup code
    cap.release();
}

TASK_CODE_END
