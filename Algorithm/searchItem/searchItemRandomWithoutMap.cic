/************************************
 *
 * File : searchItemRandomWithoutMap
 *
*************************************/

/////////////////////////////////////
// include header section
/////////////////////////////////////
TASK_CODE_BEGIN
#include <random>
#include <cmath>
#define ARROUND 0.05
using namespace std;
/////////////////////////////////////
// global definition
/////////////////////////////////////

// ##DEFINE_PORT_SECTION::START
static int ret_port;
static int room_port;
static int detect_group;
static int detect_port;
static int led_group;
static int led_port;
static int signal_group;
static int signal_port;
static EPUCKSIM_MOVE_PORTS ports;
static int turning_mechanism;
// ##DEFINE_PORT_SECTION::END

typedef struct _EPUCK_LED {
    int power;
    double red;
    double green;
    double blue;
} EPUCK_LED;

static double target[2] = {0.0, 0.0};
static int arround_bound[2];
static double map_transition_ratio[2];

static double offset[3][2][2] = {
    {{-2.325, -1.400}, {0.500, 2.275}},
    {{-1.150, 0.825}, {0.500, 2.275}},
    {{1.075, 2.075}, {0.500, 2.275}}
};

static int bound[3][2] = {
    {20, 50},
    {50, 50},
    {20, 50}
};

static int room;
static int init = FALSE;

/////////////////////////////////////
// init code
/////////////////////////////////////

TASK_INIT
{
// ##INIT_PORT_SECTION::START
    UFPort_Initialize(TASK_ID, "result", &ret_port);
    UFPort_Initialize(TASK_ID, "room", &room_port);
    UFMulticastPort_Initialize(TASK_ID, "detectItem", &detect_group, &detect_port);
    UFMulticastPort_Initialize(TASK_ID, "led", &led_group, &led_port);
    UFMulticastPort_Initialize(TASK_ID, "signal", &signal_group, &signal_port);
    UFMulticastPort_Initialize(TASK_ID, "position", &ports.position_group, &ports.position_port);
    UFMulticastPort_Initialize(TASK_ID, "orientation", &ports.orientation_group, &ports.orientation_port);
    UFMulticastPort_Initialize(TASK_ID, "proximity", &ports.proximity_group, &ports.proximity_port);
    UFMulticastPort_Initialize(TASK_ID, "wheel", &ports.wheel_group, &ports.wheel_port);
    move_init(&turning_mechanism);

// ##INIT_PORT_SECTION::END
    
    // TODO: task initialize code
    ports.robot_id = THIS_ROBOT_ID;
    int dataNum;
    EPUCK_LED led = {1, 1, -1, -1};
    UFMulticastPort_WriteToBuffer(led_group, led_port, (unsigned char *)&led, sizeof(EPUCK_LED), &dataNum); 
    int signal = 0;
    UFMulticastPort_WriteToBuffer(signal_group, signal_port, (unsigned char *)&signal, sizeof(int), &dataNum);
    target[0] = 0.0;
    target[1] = 0.0;
    room = 0;
    init = FALSE;
}


/////////////////////////////////////
// go code
/////////////////////////////////////

static void get_next_target(double *target) {
    int position[2];
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_real_distribution<> x_dis(0, bound[room][0]);
        position[0] = x_dis(gen);
        std::uniform_real_distribution<> y_dis(0, bound[room][1]);
        position[1] = y_dis(gen);
            target[0] = position[0]*map_transition_ratio[0] + offset[room][0][0];
            target[1] = offset[room][1][1] - position[1]*map_transition_ratio[1];
            return;
}

static void init_arround_position()
{
	map_transition_ratio[0] = (offset[room][0][1]-offset[room][0][0])/bound[room][0];
	map_transition_ratio[1] = (offset[room][1][1]-offset[room][1][0])/bound[room][1];
	arround_bound[0] = (int)ceil(ARROUND/map_transition_ratio[0]);
	arround_bound[1] = (int)ceil(ARROUND/map_transition_ratio[1]);
}

TASK_GO
{
    int result;
    int dataLength;
    int detect;
    int count = 0;
    int count_list[SEMO_ROBOT_NUM];
    int robot_num;
    int robot_list[SEMO_ROBOT_NUM];
    result = UFPort_ReadFromBuffer(room_port, (unsigned char *)&room, sizeof(int), 0 , &dataLength);
    ERRIFGOTO(result, EXIT_);
    result = UFMulticastPort_ReadFromBuffer(detect_group, detect_port, (unsigned char *)&detect, sizeof(int), &dataLength);
    ERRIFGOTO(result, EXIT_);
    if (detect == TRUE) {
        int ret = 1;
        LIBCALL(count, set_shared_data_action, &ret);
        result = UFPort_WriteToBuffer(ret_port, (unsigned char *)&ret, sizeof(int), 0, &dataLength);
        ERRIFGOTO(result, EXIT_);
        return;
    }
    LIBCALL(count, get_shared_data_action, &robot_num, robot_list, count_list);
    for (int i = 0 ; i < robot_num ; i++) {
        count += count_list[i];
    }
    if (count == 1) {
        int ret = 1;
        result = UFPort_WriteToBuffer(ret_port, (unsigned char *)&ret, sizeof(int), 0, &dataLength);
        ERRIFGOTO(result, EXIT_);
        return;
    }

	if (init == FALSE) {
		init_arround_position();
        get_next_target(target);
        init = TRUE;
	}

    if (is_arrived(ARROUND/2.0, &ports, target) == TRUE) {
        get_next_target(target);
    }
    move_to_target(&ports, &turning_mechanism, target);

EXIT_:
    if (result != ERR_UEM_NOERROR) {
        SEMO_LOG_ERROR("Communication error(%X)", result);
    }
}


/////////////////////////////////////
// wrapup code
/////////////////////////////////////

TASK_WRAPUP
{
    // TODO: task wrapup code
    int dataNum;
    EPUCK_LED led = {0, 0, -1, -1};
    UFMulticastPort_WriteToBuffer(led_group, led_port, (unsigned char *)&led, sizeof(EPUCK_LED), &dataNum); 
    int signal = -1;
    UFMulticastPort_WriteToBuffer(signal_group, signal_port, (unsigned char *)&signal, sizeof(int), &dataNum);
    move_wrapup(&ports);
}

TASK_CODE_END
